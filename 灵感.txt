随着分辨率的增大, 16行的存储空间越来越多, 4k的时候, 宽银幕的时候...
按S形排放1x64再编码
考虑正负差值是否做修补
把图像数据全部奇数向下取偶数，再进行差分编码。不改变编解码模块内的任何详情，适合IP黑盒的改进模式
不做差分的行不做量化可能会好一点
思考对差分值量化到底是什么意思，是不是不应该用JPEG量化表，因为JPEG量化表是为了去高频，但是差分值的“高频”是什么意思呢？？要不要试试全数值用同一个量化值的量化。
为什么我还要用2D-DCT，我直接做64点的DCT不就得了吗？
perx行积分的方式，我也不做误差积累，每一行都和每组的第一行差分怎么样？
预测像素的一般思路是给附近的其他像素点分配个权重，比如1/4left+1/4up+1/4right+1/8leftup+1/8rightup，当然也可以分配其他权重。所以可能有这样一种思路：找出4种权重分配的策略，编码时取残差最小的一种，同时把这种策略也编码进去，这样可以尽量使残差都很小，更容易做压缩。解码端就根据策略进行解码。（问题是策略怎么传输？(H.264里面看到有传输模式，而且要是当前块的预测模式和前一个相等，还可以只传输1bit信息确认，减小了传输预测模式信息的代价)）
块编码还有一个问题就是需要有点复杂的地址计算模块。
自确定关键行的方法，依然要考虑一下是和上一行的残差还是和关键行的残差。（但是关键行更新的阈值肯定是用关键行的残差进行判断）
重新确定关键行，亮度和色度的阈值应该也是不一样的。设成10的时候，bar图片亮度分量有13899次重新设置关键行，色差分量有1345/1296次重新设置关键行。（总共有1920*1080/64=32400次机会修改关键行）
甚至可以在编码的时候在对应的关键行附近寻找匹配的1x64点，以使残差更小，但同时要把左右位置偏移信息给记录下来
接上，甚至顶下前向搜索段，双向搜索段，编解码的时候不按顺序来，先编1、4块，4作为前向搜索段，23作为双向搜索段
既然编码残差，是不是不需要转换成ycbcr了，有时间测试一下性能
王刚讲过的一个特征点，是以一个像素周边的像素比该已知像素大还是小记录1010，我可以借鉴这种模式，而且增减值符合一个约定好的规律，编码的时候也根据这个规律记录对应是否增减
给大宏块一个属性，比如是平坦块，复制。向右渐变块，左右均值。垂直渐变块，上下均值。